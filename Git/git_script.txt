
#--------------------------------------------
#Git Diff
#--------------------------------------------
# 前回のコミットから変更をファイル単位で見る
git diff  --name-only HEAD~3..HEAD  （ファイル単位で出力）
git diff  --stat HEAD~3..HEAD  （ファイル単位尚且修正行数が表示される）

# 前回のコミットから変更を特定のファイルのみ確認する
git diff  4a9f44e..c92939d BCTK001/HealthCheck/HealthCheck.vbproj

# コミット間の変更を特定のフォルダだけ見る
git diff  --name-only HEAD~3..HEAD  --relative=BCTK001

# ブランチを比較
git diff master..develop
git diff --word-diff master..develop <Directory>/<FileName>

# コミット履歴でどれくらいのファイルが変更したかを見たい
git diff HEAD~3..HEAD --name-only

# リモートレポジトリとローカルリポジトリの差分を確認する
git diff HEAD..FETCH_HEAD

# 取り込み先の差分をビジュアルモードにして、取り込み元の内容を取り込む
:diffget

# Visual-mode で範囲を選択した後に、その範囲を反対側のバッファへ適用する
:diffput

# diff modeの差分情報を最新にする
:diffupdate

#--------------------------------------------
#Git Log
#--------------------------------------------
# Gitで特定ファイルの変更履歴を見る
git log -p Directory1/FileName1

# 現在のコミットから過去2回分の特定ファイル(フォルダ)の変更文字単位を見る
# e.g. 表示の仕方は 1:HEAD..HEAD~1 2:HEAD~1..HEAD~2
git log --word-diff HEAD -n 2 -p batch/BCTK005/template_html/

# 特定ファイルの過去3回分のログを見たい
git logg -n 3 -p AA/BB.txt

# 昨日からの変更したログ一覧を見たい
git logg --since='yesterday'
# 日付を指定
git logg --since='7 days'
# 月を指定
git logg --since='1 month'

git log --after '2018-05-27 00:15:00'
# 相対的な日時での指定
git log --after 'yesterday'
git log --after 'last Monday' ←先週の月曜日
# 月曜日:Monday 火曜日:Tuesday 水曜日:Wednesday 木曜日:Thursday 金曜日:Friday 土曜日:Saturday 日曜日:Sunday
git log --after '1 month 3 days ago'

# 特定ブランチのログを見たい
git logg develop

# 特定タグ以降のログを見たい
git logg start_tagName..

#--------------------------------------------
#Git Archive
#--------------------------------------------
# 前回のコミットから変更があるファイルのみ抽出して、ZIPファイルを作成
git archive --format=zip   HEAD←出力するrevision `git diff --diff-filter=ad --name-only HEAD~1..HEAD` -o archive_20190729_new.zip


#--------------------------------------------
#Git Commit
#--------------------------------------------
# 前回のコミットにもう一度コミットする
git commit --amend --no-edit

#--------------------------------------------
#Git Reset
#--------------------------------------------
# git addしたものを取り消す
git reset .


#--------------------------------------------
#Git stash commitはしないが一時的に保存する場合
#--------------------------------------------
# 一時保存の場合
git stash 

# 一時保存の保存結果を確認する場合
git stash list

# 一時保存の復活と、削除を同時に行う場合
git stash pop stash@{0}


#--------------------------------------------
#Git Checkout
#--------------------------------------------
# ブランチを作成同時に、そのブランチに切り替える
git checkout -b develop

#--------------------------------------------
#Git Merge
#--------------------------------------------
# ブランチを試してマージしてみる
git merge --no-commit --no-ff develop  ←取り込みたいブランチを指定
# 実行結果をみて、confilictがなければOK

# 現在マージ状態なので、とりあえず取り消し
git merge --abort

# ブランチをマージする(いつもマージがある部分がわかるようにする)
git merge --no-ff develop  ←取り込みたいブランチを指定

# confilictが発生した場合
    1.confilictがあるファイルを編集する（confilictを解消）
    2.git add file.txt
    3.git status
    4.git commit & git push

#--------------------------------------------
#Git Tag
#--------------------------------------------
# タグをつける
git tag -a original -m "修正前のソース"  f26ea96  ←コミット値
# タグ一覧を表示する
git tag  --sort=-taggerdate --format='%(taggerdate:short) [%(tag)]   %(subject)'
# タグを削除
git tag -d TAG_NAME
# タグ名を変更する
  既存タグを削除して、つけ直す！


#--------------------------------------------
#Git Rebase&Reset
#--------------------------------------------
# 過去のコミットのコメントを修正する(注意：必ずGitbashから実行すること)
  参考URL:https://backlog.com/ja/git-tutorial/stepup/33/

1. git rebase -i HEAD~2 　←　修正したいコミットまでのoffset + 1
2. 別ウィンドウでGvimが開かれるが、その時コミットしたいSHAのPickをEditに変更
   して終了。
3. gitBashターミナルに戻る。
4. VisualStudioもしくはvimでファイルを修正する。
5. いつもの通り、 git status&git add
6. git commit --amend --no-editで修正を反映する。
7. git rebase --continue でRebase作業を終了する。


途中でやめたい場合は、git rebase --abort

# rebaseを過去に戻したい
git reflog ←　コミット履歴確認用
git reset --hard HEAD@{4} 　←一般的にはこれを使う
git reset --hard ORIG_HEAD ←rebase直後に使える

#--------------------------------------------
#Git Remote
#--------------------------------------------
# リモートレポジトリの一覧を取得する
git remote -v

# リモートレポジトリの最新を取得する
git fetch
evertokyo

# ローカルリポジトリの変更をリモートのoriginリポジトリとmasterタグに反映する。
git push origin master

# こんなエラーがあった場合
error: failed to push some refs to 'https://github.com/...'の場合

解決策1:
git fetch
git rebase origin/master

解決策2:
git fetch
git merge origin/master


#--------------------------------------------
#Git Branch
#--------------------------------------------
# 現在開いているブランチの名前を変更
git branch -m newBranchName

# ブランチを削除
git branch --delete hotfix
Or
git branch -d hotfix

# 消してしまったブランチを復活させるには？
git reflog
# 消してしまったブランチの最後のコミットを見つけたら
git branch ブランチ名 HEAD@{ログ番号}


# ブランチのおすすめモデル
【開発作業の流れ】
1. masterブランチからdevelopブランチを作成
2. developブランチから実装する機能毎にfeatureブランチを作成
3. featureブランチで実装完了した機能はdevelopブランチにマージ
4. リリース作業開始時点で、developからreleaseブランチを作成
5. リリース作業完了時点で、releaseからdevelop, masterブランチにマージ

【リリース後の障害対応の流れ】
1. masterブランチからhotfixブランチを作成
2. hotfixブランチで障害対応が完了した時点で、develop, masterブランチにマージ

# **hotfixブランチ
製品のリリース時には、時として重大な不具合が見つかる場合があります。みなさんも経験があるのではないでしょうか？

そんなときには、master ブランチから直接 hotfix
ブランチを切って緊急の修正を行いましょう。修正完了後に master ブランチと develop
ブランチにマージして、リリースタグ（マイナーバージョンなど）をうちます。その後、hotfix
ブランチは削除します。派生元が master になるだけで、操作的には release
ブランチと同様です。

# masterブランチの途中からhotfixを切る
git logg  <- コミット一覧を見る
git checkout -b hotfix 7f7798e  <-  新しいブランチhotfixを特定のコミットから切る
【登場するブランチ】
master:
　リリースした時点のソースコードを管理するブランチ

develop (masterから派生):
　開発作業の主軸となるブランチ

feature (developから派生):
　実装する機能毎のブランチ (feature/◯◯, feature/xxなど)

release (developから派生):
　developでの開発作業完了後、リリース時の微調整を行うブランチ
　(バージョン番号の変更などで使いました。)

hotfix (masterから派生):
　リリースされた製品に致命的なバグ(クラッシュなど)があった場合に緊急対応をするためのブランチ


# SVNとの連携
#--------------------------------------------
#Git Svn
#--------------------------------------------
# Clone a repo (like git clone):
	git svn clone http://svn.example.com/project/trunk
# You should be on master branch, double-check with 'git branch'(ブランチremotes/git-svnが存在することを確認)
	git branch
# Do some work and commit locally to Git:
	git commit ...
# Something is committed to SVN, rebase your local changes against the
# latest changes in SVN:(SVNでコミットしたものをGitに取り込む)
	git svn rebase
# Now commit your changes (that were committed previously using Git) to SVN,
# as well as automatically updating your working HEAD:
	git svn dcommit
# Append svn:ignore settings to the default Git exclude file:
	git svn show-ignore >> .git/info/exclude


# Gitのignore
#--------------------------------------------
#Git ignore
#--------------------------------------------
# .gitignore を設置しても、既にリポジトリに登録されているファイルは無視されないので、
無視したいファイルを管理対象から外します。
（なお、管理対象から外れるだけで、ローカルにあるファイルは削除されません）
git rm -r --cached hoge.tmp
か全部のキャッシュを削除する際には↓↓
git rm -r --cached .

#既に大量のファイルが登録されている場合
git rm -r --cached `git ls-files --full-name -i --exclude-from=.gitignore`

#ファルダ名に半角スペースがある場合
git rm -r --cached "test space/sub"

#おまけ
git add .
git commit -m ".gitignore is now working"
git push origin master


# 作業を一時退避
#--------------------------------------------
#Git stash
#--------------------------------------------
# 現在の作業を一時的に退避したい
git stash

# 現在の作業を一時的に退避したい
git stash pop

# 退避した作業の一覧を表示したい
git stash list

# 退避した作業を削除したい(退避した作業の中で最新の作業を削除)
git stash drop

# 退避した作業を全て削除したい
git stash clear

